<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>幾何教具：面積分解與合成工具 (CodeCrafter)</title>
    <!-- 引入 Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 html2canvas CDN for image download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> 
    <style>
        /* 自定義 CSS 確保網格和拖曳功能視覺效果良好 */
        .grid-unit {
            border: 1px solid #ccc;
            box-sizing: border-box;
            background-color: white;
            transition: all 0.1s ease-out;
            cursor: grab;
            /* 針對觸控優化，確保拖曳順暢 */
            touch-action: none; 
            /* 讓方塊顯示網格效果 */
            background-image: linear-gradient(to right, #e5e7eb 1px, transparent 1px), linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px; /* 單位格尺寸 (20px x 20px) */
        }
        /* Mode 1: 剩餘的紅色邊角料 */
        .grid-unit.red-remainder {
            background-color: #ef4444 !important; /* red-500 */
        }
        /* Mode 2: 合成的正方形 (紅底) */
        .grid-unit.is-square {
            background-color: #dc2626 !important; /* red-700 for detected square in compose mode */
            border: 3px solid #f97316; /* Orange ring for emphasis */
            box-shadow: 0 0 10px rgba(220, 38, 38, 0.7);
        }
        /* Mode 1: 已切割的原長方形 (半透明線框，用於比較) */
        .cut-original {
            background-color: rgba(209, 213, 219, 0.4) !important; /* Gray/transparent */
            border: 2px dashed #9ca3af !important; /* Dashed grey border */
            box-shadow: none !important;
        }

        /* 外層視口：固定高度，允許捲動 */
        .workspace-viewport {
            height: 800px; 
            min-height: 70vh; /* 確保在垂直空間大的螢幕上佔用更多空間 */
            border: 2px dashed #4b5563; /* Darker border */
            background-color: #204038; /* Deep dark green */
            position: relative;
            overflow: auto; /* 啟用捲動功能 */
        }
        /* 內層內容：巨大空間，將被縮放 */
        #canvas-container {
            width: 3000px; /* 邏輯上的大空間 */
            height: 3000px; /* 邏輯上的大空間 */
            position: relative;
            transform-origin: top left;
            transition: transform 0.2s ease;
            /* 確保背景網格對齊 content 而非 viewport */
            background-color: #204038; /* Deep dark green */
        }
        /* 繪圖圖層，覆蓋在積木下方 */
        #drawing-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 25; 
            /* 預設禁止事件捕捉，讓事件穿透到下層積木 */
            pointer-events: none;
        }
        /* 當繪圖工具被選中時，才啟用事件捕捉 */
        .drawing-active #drawing-layer {
            pointer-events: all;
        }

        /* 隱藏原生數字輸入框的上下箭頭 */
        input[type='number']::-webkit-inner-spin-button,
        input[type='number']::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .dialog {
            z-index: 50;
        }
        .tool-active {
            box-shadow: 0 0 0 3px #3b82f6; /* Ring-blue-500 */
            background-color: #3b82f6;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans antialiased text-gray-800">

    <!-- 頂部標題 -->
    <header class="bg-white shadow-lg sticky top-0 z-40">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            <h1 class="text-3xl font-extrabold text-indigo-600">幾何互動教具：最大公因數體驗</h1>
        </div>
    </header>

    <main class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <!-- 訊息/錯誤提示區 -->
        <div id="message-box" class="mb-4 hidden p-3 rounded-lg bg-yellow-100 text-yellow-800 border border-yellow-300"></div>
        
        <!-- 模式選擇畫面 -->
        <section id="start-screen" class="flex flex-col items-center justify-center min-h-[50vh] transition-opacity duration-300">
            <h2 class="text-4xl font-bold mb-8 text-gray-700">請選擇操作模式</h2>
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-8">
                <button onclick="setMode('cut')" class="mode-btn bg-indigo-600 hover:bg-indigo-700 text-white p-6 rounded-xl shadow-xl transition transform hover:scale-[1.02] text-2xl font-semibold w-full sm:w-64">
                    大拆小 (體驗因數與餘數)
                </button>
                <button onclick="setMode('compose')" class="mode-btn bg-teal-600 hover:bg-teal-700 text-white p-6 rounded-xl shadow-xl transition transform hover:scale-[1.02] text-2xl font-semibold w-full sm:w-64">
                    小組大 (探索正方形組合)
                </button>
            </div>
        </section>

        <!-- 主要工作區 (預設隱藏) -->
        <section id="main-workspace" class="hidden transition-opacity duration-300">
            <!-- 模式標題和返回按鈕 -->
            <div class="flex justify-between items-center mb-6">
                <h2 id="mode-title" class="text-3xl font-bold text-gray-700"></h2>
                <button onclick="showStartScreen()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg transition duration-150">
                    < Back 返回模式選擇
                </button>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
                <!-- 控制面板區 (左側) -->
                <div class="lg:col-span-1 space-y-4 p-4 bg-white rounded-xl shadow-lg h-fit">
                    <h3 class="text-xl font-semibold border-b pb-2 mb-3">操作控制</h3>

                    <!-- 模式 1: 大拆小 (切割) 控制項 -->
                    <div id="controls-cut" class="space-y-4 hidden">
                        <div class="space-y-2">
                            <label class="block text-sm font-medium text-gray-700">原始長方形尺寸 (單位格)</label>
                            <input type="number" id="cut-length" placeholder="長度 (L)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" min="1">
                            <input type="number" id="cut-width" placeholder="寬度 (W)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" min="1">
                            <button onclick="renderInitialGrid()" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 rounded-lg transition duration-150">
                                建立新長方形 (可比較切法)
                            </button>
                        </div>
                        <p class="text-sm text-gray-500 pt-2 border-t mt-4">
                            **GCD 體驗：** 嘗試找到一個正方形邊長，能將長和寬都切割到剛好，使紅色剩餘區為空。這個最大的邊長就是最大公因數。
                        </p>
                    </div>

                    <!-- 模式 2: 小組大 (合成) 控制項 -->
                    <div id="controls-compose" class="space-y-4 hidden">
                        <div class="space-y-2">
                            <label class="block text-sm font-medium text-gray-700">單位長方形尺寸 (單位格)</label>
                            <input type="number" id="compose-unit-length" placeholder="單位長度 (L)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-teal-500 focus:border-teal-500" value="1" min="1">
                            <input type="number" id="compose-unit-width" placeholder="單位寬度 (W)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-teal-500 focus:border-teal-500" value="1" min="1">
                            <button onclick="renderSupplyArea()" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 rounded-lg transition duration-150">
                                建立單位積木
                            </button>
                        </div>

                        <!-- 供應區 (僅用於 Mode 2) -->
                        <div class="pt-4 border-t">
                            <h4 class="text-lg font-medium mb-2">供應區 (拖曳至畫布)</h4>
                            <div id="supply-area" class="flex flex-wrap gap-2 p-2 border border-gray-200 rounded-lg min-h-[60px] bg-gray-50">
                                <!-- 單位積木將會被 JS 動態加入 -->
                            </div>
                        </div>
                    </div>

                    <!-- 繪圖工具區塊 (更新) -->
                    <div class="pt-4 border-t space-y-3">
                        <h4 class="text-lg font-medium border-b pb-2">繪圖工具</h4>
                        <div class="flex space-x-2">
                             <!-- 新增 選取工具 -->
                            <button id="select-tool" onclick="setTool('select')" class="w-1/3 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 rounded-lg transition duration-150 flex items-center justify-center tool-active">
                                選取
                            </button>
                            <button id="chalk-tool" onclick="setTool('chalk')" class="w-1/3 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                                粉筆
                            </button>
                            <button id="eraser-tool" onclick="setTool('eraser')" class="w-1/3 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                                橡皮擦
                            </button>
                        </div>
                        <div class="space-y-1">
                            <label for="brush-size" class="block text-sm font-medium text-gray-700">筆刷大小 (<span id="brush-size-display">5</span>)</label>
                            <input type="range" id="brush-size" min="2" max="20" step="1" value="5" oninput="updateBrushSize(this.value)" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <button onclick="clearDrawing()" class="w-full bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                            清除塗鴉
                        </button>
                    </div>

                    <div class="pt-4 border-t space-y-3">
                         <h4 class="text-lg font-medium border-b pb-2">畫布縮放/畫面操作</h4>
                        <!-- 縮放拉桿 (取代原本的 +/- 按鈕) -->
                         <div class="space-y-1">
                            <label id="scale-label" class="block text-sm font-medium text-gray-700">畫布縮放 (100%)</label>
                            <input type="range" id="scale-slider" min="0.6" max="2.0" step="0.1" value="1.0" oninput="handleScaleChange(event)" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        </div>

                         <!-- 畫面操作按鈕 -->
                        <button onclick="downloadScreen()" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                             <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4m-6-4l-3 3m0 0l-3-3m3 3V3"></path></svg>
                            下載畫面 (圖片)
                        </button>
                        <!-- 清除畫面按鈕 (已修正) -->
                        <button onclick="confirmNewScreen()" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                             <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v3m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            清除畫面
                        </button>
                    </div>
                </div>

                <!-- 畫布/工作區 (右側) -->
                <div class="lg:col-span-3">
                    <div id="canvas-viewport" class="workspace-viewport rounded-xl shadow-inner relative">
                        <div id="canvas-container" class="workspace-content">
                             <!-- 繪圖層 (新增) -->
                            <canvas id="drawing-layer"></canvas>
                            <!-- 幾何圖形將在此處渲染 -->
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- 切割輸入彈窗 (Modal) -->
    <div id="cut-modal" class="dialog fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm space-y-4">
            <h3 class="text-xl font-bold">切割操作</h3>
            <p>請決定要用多少「單位格邊長」的正方形來切割這個長方形:</p>
            
            <div class="flex items-center space-x-3">
                <label for="cut-square-size" class="font-medium">正方形邊長 (單位格):</label>
                <input type="number" id="cut-square-size" class="w-20 p-2 border border-gray-300 rounded-lg text-center" min="1">
            </div>

            <p id="cut-info" class="text-sm text-gray-500"></p>

            <div class="flex justify-end space-x-3">
                <button onclick="closeCutModal()" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 rounded-lg">取消</button>
                <button onclick="performCut()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg">確認切割</button>
            </div>
        </div>
    </div>
    
    <!-- 警告/確認彈窗 (用於清除畫面) -->
    <div id="confirm-modal" class="dialog fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm space-y-4">
            <h3 class="text-xl font-bold text-red-600">確認清除畫面</h3>
            <p>您確定要清除目前畫布上的所有內容，並開啟一個新的畫面嗎？此操作無法撤銷。</p>
            <div class="flex justify-end space-x-3">
                <button onclick="closeConfirmModal()" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 rounded-lg">取消</button>
            <button onclick="newScreen(false)" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg">確認清除</button> 
            </div>
        </div>
    </div>


    <!-- 移除 Firebase 相關腳本區塊 -->

    <script>
        // ==== 全局狀態與配置 ====
        const GRID_SIZE = 20; // 每個單位方格在螢幕上的像素大小
        const MIN_SCALE = 0.6;  // 最小縮放比例
        const MAX_SCALE = 2.0;  // 最大縮放比例

        let currentState = {
            mode: null, // 'cut' or 'compose'
            shapes: [],
            dims: { length: 0, width: 0 } 
        };
        let draggingShape = null;
        let dragOffset = { x: 0, y: 0 };
        let cutTargetShape = null; // 儲存 Mode 1 中被點擊的長方形
        let currentScale = 1.0; // 當前縮放比例
        let dragStartPos = { x: 0, y: 0 }; // 追蹤拖曳起始點，用於區分點擊或拖曳

        // 用於 Mode 1 群組拖曳
        let groupToMove = [];
        let groupOffset = { x: 0, y: 0 };

        // ==== 繪圖工具狀態 (新增) ====
        let drawingCanvas, ctx;
        let isDrawing = false;
        let currentTool = 'select'; // 預設為 'select'
        let brushSize = 5;
        let lastX = 0, lastY = 0;


        // ==== 縮放功能 (Slider) ====
        const canvasContainer = document.getElementById('canvas-container');
        const canvasViewport = document.getElementById('canvas-viewport');

        const updateScaleDisplay = () => {
            // 使用 CSS Transform 縮放內容
            canvasContainer.style.transform = `scale(${currentScale})`;
            document.getElementById('scale-slider').value = currentScale.toFixed(1);
            document.getElementById('scale-label').textContent = `畫布縮放 (${Math.round(currentScale * 100)}%)`;
        };

        const handleScaleChange = (event) => {
            currentScale = parseFloat(event.target.value);
            updateScaleDisplay();
        };

        // 啟動時確保拉桿和顯示同步，並初始化繪圖工具
        document.addEventListener('DOMContentLoaded', () => {
            updateScaleDisplay();
            
            // 繪圖工具初始化
            drawingCanvas = document.getElementById('drawing-layer');
            // 設定 canvas 尺寸與父容器 (3000x3000) 一致
            drawingCanvas.width = 3000;
            drawingCanvas.height = 3000;
            
            ctx = drawingCanvas.getContext('2d');
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = brushSize;
            ctx.strokeStyle = 'white'; // 預設粉筆顏色
            
            // 初始設定為選取工具 (select)
            setTool('select'); 

            // 綁定繪圖事件
            drawingCanvas.addEventListener('pointerdown', startDraw);
            drawingCanvas.addEventListener('pointermove', draw);
            drawingCanvas.addEventListener('pointerup', stopDraw);
            drawingCanvas.addEventListener('pointerout', stopDraw);
        });
        
        // ==== 繪圖工具邏輯 (新增) ====
        
        const setTool = (tool) => {
            // 取消拖曳操作，避免衝突
            draggingShape = null; 
            
            currentTool = tool;
            
            const toolButtons = ['select', 'chalk', 'eraser'];
            toolButtons.forEach(t => {
                document.getElementById(`${t}-tool`).classList.remove('tool-active');
            });
            document.getElementById(`${tool}-tool`).classList.add('tool-active');

            // --- 核心衝突解決邏輯 ---
            if (tool === 'select') {
                // 選取模式: 移除 drawing-active class，讓事件穿透 canvas
                canvasContainer.classList.remove('drawing-active');
                showMessage('已選取 **選取工具** (可拖曳積木)', false);
            } else {
                // 繪圖模式: 加入 drawing-active class，讓 canvas 捕捉事件
                canvasContainer.classList.add('drawing-active');
                
                // 設定繪圖/橡皮擦模式
                ctx.globalCompositeOperation = tool === 'chalk' ? 'source-over' : 'destination-out';
                ctx.strokeStyle = tool === 'chalk' ? 'white' : 'rgba(0,0,0,1)'; 
                ctx.lineWidth = brushSize;

                showMessage(`已選取 **${tool === 'chalk' ? '粉筆' : '橡皮擦'}** (可繪圖)`, false);
            }
        };
        
        const updateBrushSize = (size) => {
            brushSize = parseInt(size);
            document.getElementById('brush-size-display').textContent = brushSize;
            ctx.lineWidth = brushSize;
        };

        const getCanvasCoords = (e) => {
            const viewportRect = canvasViewport.getBoundingClientRect();
            
            // 計算點擊點在【未縮放】的內容區的座標
            const clientXUnscaled = (e.clientX - viewportRect.left + canvasViewport.scrollLeft) / currentScale;
            const clientYUnscaled = (e.clientY - viewportRect.top + canvasViewport.scrollTop) / currentScale;
            
            return { x: clientXUnscaled, y: clientYUnscaled };
        };

        const startDraw = (e) => {
            // 在 CSS 中已控制事件穿透，此處只需檢查是否處於繪圖模式
            if (currentTool === 'select') return;

            e.preventDefault(); 
            e.stopPropagation(); 

            isDrawing = true;
            const coords = getCanvasCoords(e);
            lastX = coords.x;
            lastY = coords.y;
            
            // 立即畫一個點
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(lastX + 0.5, lastY + 0.5); 
            ctx.stroke();
            
        };

        const draw = (e) => {
            if (!isDrawing || currentTool === 'select') return;
            e.preventDefault();
            
            const coords = getCanvasCoords(e);

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(coords.x, coords.y);
            ctx.stroke();

            lastX = coords.x;
            lastY = coords.y;
        };

        const stopDraw = () => {
            isDrawing = false;
        };
        
        const clearDrawing = () => {
            if (!ctx) return;
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            showMessage('塗鴉已清除。', false);
        };


        // ==== UI/彈窗工具函數 ====
        const messageBox = document.getElementById('message-box');
        const showMessage = (msg, isError = false) => {
            messageBox.textContent = msg;
            messageBox.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800');
            messageBox.classList.add(isError ? 'bg-red-100' : 'bg-yellow-100', isError ? 'text-red-800' : 'text-yellow-800');
            
            // 3秒後自動隱藏，除非是錯誤
            if (!isError) {
                setTimeout(() => messageBox.classList.add('hidden'), 3000);
            }
        };

        const showStartScreen = () => {
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('main-workspace').classList.add('hidden');
            currentState.mode = null;
            newScreen(false); 
        };

        const setMode = (mode) => {
            currentState.mode = mode;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('main-workspace').classList.remove('hidden');

            const titleElement = document.getElementById('mode-title');
            const cutControls = document.getElementById('controls-cut');
            const composeControls = document.getElementById('controls-compose');

            if (mode === 'cut') {
                titleElement.textContent = '模式：大拆小 (體驗因數與餘數)';
                cutControls.classList.remove('hidden');
                composeControls.classList.add('hidden');
            } else {
                titleElement.textContent = '模式：小組大 (探索正方形組合)';
                cutControls.classList.add('hidden');
                composeControls.classList.remove('hidden');
            }
            newScreen(false);
        };

        // ==== 畫面下載功能 ====
        const downloadScreen = () => {
            showMessage('正在捕捉畫面並下載...', false);
            // 捕捉的目標是包含內容的 container
            const targetElement = canvasContainer; 
            
            // 確保背景為白色
            targetElement.style.backgroundColor = '#ffffff';
            
            // 暫時重置縮放，確保截圖尺寸正確
            const originalScale = currentScale;
            targetElement.style.transform = `scale(1.0)`;

            // 調整 canvas 的實際大小，使其剛好包住所有積木
            let maxW = 0, maxH = 0;
            currentState.shapes.filter(s => s.type !== 'supply').forEach(s => {
                maxW = Math.max(maxW, s.x + s.l * GRID_SIZE);
                maxH = Math.max(maxH, s.y + s.w * GRID_SIZE);
            });
            const originalWidth = targetElement.style.width;
            const originalHeight = targetElement.style.height;
            
            targetElement.style.width = `${maxW + 40}px`; // 留出邊界
            targetElement.style.height = `${maxH + 40}px`;

            html2canvas(targetElement, { 
                scale: 2, 
                useCORS: true, 
                // 為了讓 html2canvas 處理整個大的內容區
                width: maxW + 40,
                height: maxH + 40
            }).then(canvas => {
                // 恢復背景色、尺寸和縮放
                targetElement.style.backgroundColor = '#204038'; // 恢復深綠色
                targetElement.style.transform = `scale(${originalScale})`;
                targetElement.style.width = originalWidth;
                targetElement.style.height = originalHeight;
                
                // 轉換為圖片連結並下載
                const image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
                const link = document.createElement('a');
                link.download = `幾何教具畫面_${new Date().getTime()}.png`;
                link.href = image;
                link.click();
                showMessage('畫面下載完成！', false);
            }).catch(e => {
                console.error("畫面下載失敗: ", e);
                // 確保狀態被恢復
                targetElement.style.backgroundColor = '#204038'; // 恢復深綠色
                targetElement.style.transform = `scale(${originalScale})`;
                targetElement.style.width = originalWidth;
                targetElement.style.height = originalHeight;
                showMessage('下載畫面失敗，請確保畫布上有內容。', true);
            });
        };


        // ==== 核心畫布渲染與互動 ====
        
        const renderCanvas = () => {
            canvasContainer.innerHTML = '';
            
            // 1. 先把繪圖層放回去
            if (drawingCanvas) {
                 canvasContainer.appendChild(drawingCanvas);
            }
            
            // 2. 渲染所有形狀
            currentState.shapes.forEach(shape => {
                const el = document.createElement('div');
                el.id = shape.id;
                
                // 基礎樣式
                el.className = 'grid-unit absolute rounded-md shadow-md transition-shadow duration-200';
                el.style.width = `${shape.l * GRID_SIZE}px`;
                el.style.height = `${shape.w * GRID_SIZE}px`;
                el.style.left = `${shape.x}px`;
                el.style.top = `${shape.y}px`;
                el.style.zIndex = shape.type === 'supply' ? 10 : 30; // 供應區在下方

                // --- Mode 1: 切割邏輯 ---
                if (currentState.mode === 'cut' && shape.type === 'initial') {
                    if (shape.isCut) {
                         el.classList.add('cut-original'); // 線框模式
                         el.style.zIndex = 10;
                    } else {
                         // 待切割長方形 - 移除 onclick，改由 endDrag 判斷是否為點擊
                        el.style.cursor = 'pointer';
                        el.style.zIndex = 20;
                        el.style.backgroundColor = 'white';
                    }
                }
                // Mode 1: 剩餘邊角料
                else if (currentState.mode === 'cut' && shape.type === 'remainder') {
                    el.classList.add('red-remainder');
                    el.style.zIndex = 30;
                }
                // Mode 2: 合成的積木 (Block) 或切割後的正方形 (Cut-Square)
                else {
                    el.style.backgroundColor = shape.color || 'white';
                    el.style.zIndex = 30;
                }
                
                // Mode 2: 合成正方形變紅
                if (currentState.mode === 'compose' && shape.type === 'block' && shape.isSquare) {
                    el.classList.add('is-square', 'cursor-pointer');
                    el.setAttribute('title', '點擊複製此正方形');
                    el.onclick = (e) => {
                        e.stopPropagation(); 
                        duplicateShape(shape)
                    };
                }

                // --- 統一拖曳事件 (所有非供應區的積木都需要拖曳功能來整理畫面) ---
                const isDraggable = (shape.type !== 'supply');

                if (isDraggable) {
                    el.onpointerdown = (e) => startDrag(e, shape, false, el);
                }

                canvasContainer.appendChild(el);
            });

            // 綁定拖曳結束事件到外層 Viewport
            canvasViewport.onpointerup = endDrag;
            canvasViewport.onpointermove = onDrag;
            canvasViewport.onpointercancel = endDrag;
            
            // 確保縮放狀態正確顯示
            updateScaleDisplay(); 
        };

        // 清除畫布
        const newScreen = (showConfirmation = true) => {
             if (showConfirmation) {
                document.getElementById('confirm-modal').classList.remove('hidden');
                document.getElementById('confirm-modal').classList.add('flex');
                return;
            }

            // 實際清除邏輯
            currentState.shapes = [];
            currentState.dims = { length: 0, width: 0 };
            document.getElementById('cut-length').value = '';
            document.getElementById('cut-width').value = '';
            document.getElementById('compose-unit-length').value = '1';
            document.getElementById('compose-unit-width').value = '1';
            document.getElementById('supply-area').innerHTML = '';
            clearDrawing(); // 清除塗鴉層 (新增)
            renderCanvas();
            closeConfirmModal();
            showMessage('畫面已重置。', false);
        };
        const closeConfirmModal = () => {
            document.getElementById('confirm-modal').classList.add('hidden');
            document.getElementById('confirm-modal').classList.remove('flex');
        };
        const confirmNewScreen = () => newScreen(true);
        

        // ==== Mode 1: 大拆小 (切割) 邏輯 ====
        
        // 輔助函數：找到一個不與現有形狀重疊的起始位置
        const findNewPlacement = (l, w) => {
            // 由於內容區是 3000x3000，我們只在左上角 (0,0) 附近的區域尋找
            const searchLimitUnits = 50; 

            for (let y = 1; y < searchLimitUnits - w; y++) {
                for (let x = 1; x < searchLimitUnits - l; x++) {
                    const newShapeBoundary = {
                        x: x * GRID_SIZE,
                        y: y * GRID_SIZE,
                        l: l,
                        w: w
                    };
                    
                    let overlaps = false;
                    for (const existingShape of currentState.shapes.filter(s => s.type !== 'supply')) {
                        // 檢查重疊 (使用網格單元)
                        if (newShapeBoundary.x < existingShape.x + existingShape.l * GRID_SIZE &&
                            newShapeBoundary.x + newShapeBoundary.l * GRID_SIZE > existingShape.x &&
                            newShapeBoundary.y < existingShape.y + existingShape.w * GRID_SIZE &&
                            newShapeBoundary.y + newShapeBoundary.w * GRID_SIZE > existingShape.y) {
                            overlaps = true;
                            break;
                        }
                    }
                    if (!overlaps) {
                        return { x: newShapeBoundary.x, y: newShapeBoundary.y };
                    }
                }
            }
            return { x: 20, y: 20 }; // 如果找不到空間，使用預設值
        };


        const renderInitialGrid = () => {
            const length = parseInt(document.getElementById('cut-length').value);
            const width = parseInt(document.getElementById('cut-width').value);

            if (isNaN(length) || isNaN(width) || length <= 0 || width <= 0) {
                showMessage('請輸入有效的長度和寬度 (需為正整數)。', true);
                return;
            }
            
            currentState.dims = { length, width };
            const groupId = 'group-' + Date.now(); // 為新的長方形定義群組 ID

            const { x: newX, y: newY } = findNewPlacement(length, width);

            const initialShape = {
                id: 'initial-' + Date.now(),
                type: 'initial',
                l: length,
                w: width,
                x: newX,
                y: newY,
                color: 'white',
                isCut: false, 
                isInitial: true,
                groupId: groupId // 賦予群組 ID
            };
            currentState.shapes.push(initialShape);
            renderCanvas();
            showMessage(`已建立新的 ${length}x${width} 長方形。點擊它來切割。`, false);
        };

        const openCutModal = (shape) => {
            if (shape.isCut) return; 
            cutTargetShape = shape;
            document.getElementById('cut-square-size').value = 1; 
            document.getElementById('cut-info').textContent = `目標長方形尺寸: ${shape.l} (長) x ${shape.w} (寬)`;

            document.getElementById('cut-modal').classList.remove('hidden');
            document.getElementById('cut-modal').classList.add('flex');
        };

        const closeCutModal = () => {
             document.getElementById('cut-modal').classList.add('hidden');
             document.getElementById('cut-modal').classList.remove('flex');
        };
        
        const performCut = () => {
            if (!cutTargetShape) return;

            const target = cutTargetShape;
            const squareSize = parseInt(document.getElementById('cut-square-size').value);

            if (isNaN(squareSize) || squareSize <= 0 || squareSize > Math.min(target.l, target.w)) {
                showMessage(`切割的正方形邊長必須是正整數，且不能大於長或寬 (${target.l}x${target.w})`, true);
                return;
            }

            // 1. 將原始大矩形標記為「已切割」
            target.isCut = true;
            const groupId = target.groupId; // 獲取群組 ID

            let currentL = target.l;
            let currentW = target.w;
            let currentX = target.x;
            let currentY = target.y;

            // 2. 計算可切出多少個完整的正方形
            const numL = Math.floor(currentL / squareSize);
            const numW = Math.floor(currentW / squareSize);
            
            let cutCount = 0;

            // 3. 產出切割後的正方形
            for (let i = 0; i < numL; i++) {
                for (let j = 0; j < numW; j++) {
                    const newSquare = {
                        id: 'cut-sq-' + Date.now() + '-' + i + j,
                        type: 'cut-square',
                        l: squareSize,
                        w: squareSize,
                        x: currentX + i * squareSize * GRID_SIZE,
                        y: currentY + j * squareSize * GRID_SIZE,
                        color: 'white',
                        isSquare: true,
                        groupId: groupId // 繼承群組 ID
                    };
                    currentState.shapes.push(newSquare);
                    cutCount++;
                }
            }
            
            // 4. 計算剩餘部分
            const remainderL = currentL % squareSize;
            const remainderW = currentW % squareSize;
            
            // 剩餘矩形 1: 在長度方向被切掉後，寬度方向的殘餘部分 (位於右側)
            if (remainderL > 0) {
                const remainderShape = {
                    id: 'rem-l-' + Date.now(),
                    type: 'remainder',
                    l: remainderL,
                    w: currentW, // 整個寬度
                    x: currentX + numL * squareSize * GRID_SIZE,
                    y: currentY,
                    color: 'red',
                    isSquare: false,
                    groupId: groupId // 繼承群組 ID
                };
                currentState.shapes.push(remainderShape);
                cutCount++;
            }

            // 剩餘矩形 2: 在寬度方向被切掉後，長度方向的殘餘部分 (位於下方)
            if (remainderW > 0) {
                const remainderShape = {
                    id: 'rem-w-' + Date.now(),
                    type: 'remainder',
                    l: numL * squareSize, // 僅限被完整切出正方形的長度
                    w: remainderW,
                    x: currentX,
                    y: currentY + numW * squareSize * GRID_SIZE,
                    color: 'red',
                    isSquare: false,
                    groupId: groupId // 繼承群組 ID
                };
                currentState.shapes.push(remainderShape);
                cutCount++;
            }


            // 5. 更新並關閉
            cutTargetShape = null;
            closeCutModal();
            renderCanvas();
            showMessage(`已在原長方形上切割出 ${cutCount} 個新形狀。`, false);
        };


        // ==== Mode 2: 小組大 (合成) 邏輯 ====
        
        const renderSupplyArea = () => {
            const supplyArea = document.getElementById('supply-area');
            supplyArea.innerHTML = '';
            
            const l = parseInt(document.getElementById('compose-unit-length').value);
            const w = parseInt(document.getElementById('compose-unit-width').value);

            if (isNaN(l) || isNaN(w) || l <= 0 || w <= 0) {
                showMessage('請輸入有效的單位長度和寬度 (需為正整數)。', true);
                return;
            }
            currentState.dims = { length: l, width: w };


            // 檢查供應區是否已經有此單位的形狀，如果沒有，就新增一個。
            const existingSupplyShape = currentState.shapes.find(s => s.type === 'supply' && s.l === l && s.w === w);
            if (!existingSupplyShape) {
                 const supplyShape = {
                    id: 'supply-' + l + 'x' + w,
                    type: 'supply',
                    l: l,
                    w: w,
                    x: 0, 
                    y: 0,
                    color: 'white',
                    isSquare: l === w
                };
                currentState.shapes.push(supplyShape);
            }
            
            // 在供應區創建可拖曳的原型
            const supplyElement = document.createElement('div');
            supplyElement.id = 'supply-proto-' + l + 'x' + w;
            supplyElement.className = 'grid-unit shadow-lg cursor-pointer hover:shadow-xl transition';
            supplyElement.style.width = `${l * GRID_SIZE}px`;
            supplyElement.style.height = `${w * GRID_SIZE}px`;
            supplyElement.textContent = `${l}x${w}`;
            supplyElement.style.lineHeight = `${w * GRID_SIZE}px`;
            supplyElement.style.textAlign = 'center';
            supplyElement.style.fontSize = '12px';
            supplyElement.style.position = 'relative'; 
            supplyElement.style.zIndex = 10; 

            // 複製事件 (從供應區拖曳時)
            supplyElement.onpointerdown = (e) => {
                e.stopPropagation(); 
                
                // 1. 創建一個新的 shape 實例
                const newShape = {
                    id: 'block-' + Date.now(),
                    type: 'block',
                    l: l,
                    w: w,
                    // 初始位置設定在畫布左上角，等待 startDrag 調整
                    x: canvasViewport.scrollLeft + 50, 
                    y: canvasViewport.scrollTop + 50, 
                    color: 'white',
                    isSquare: l === w,
                    isDragging: true
                };

                currentState.shapes.push(newShape);
                renderCanvas(); 
                
                // 2. 找到新渲染的 DOM 元素並開始拖曳
                const el = document.getElementById(newShape.id);
                if (el) {
                    // 傳遞 isNew=true 給 startDrag
                    startDrag(e, newShape, true, el); 
                } else {
                     currentState.shapes.pop(); 
                }
            };

            supplyArea.appendChild(supplyElement);
        };
        
        // 複製紅色正方形 (F. 紅色的正方形可以長按複製出來 - 改為點擊)
        const duplicateShape = (shape) => {
            if (!shape.isSquare || currentState.mode !== 'compose') return;

            const newShape = {
                id: 'block-' + Date.now(),
                type: 'block',
                l: shape.l,
                w: shape.w,
                x: shape.x + GRID_SIZE, // 稍微偏移
                y: shape.y + GRID_SIZE,
                color: 'white', 
                isSquare: false, 
                isDragging: false 
            };
            currentState.shapes.push(newShape);
            renderCanvas();
            showMessage(`已複製一個 ${shape.l}x${shape.w} 的積木。`, false);
        };

        // 輔助函數：將像素位置對齊到網格
        const findNearestGridPosition = (x, y) => {
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        };

        // 拖曳開始
        const startDrag = (e, shape, isNew = false, el = null) => {
            // 如果當前是繪圖工具，則阻止積木拖曳 (雙重檢查，CSS 應已處理)
            if (currentTool !== 'select') return;
            
            // 所有非供應區的積木都可以拖曳
            if (shape.type === 'supply') return;

            // 確保是左鍵點擊 (或觸摸開始)
            if (e.button !== 0 && !e.pointerType.includes('touch')) return; 
            e.preventDefault();
            e.stopPropagation();

            draggingShape = shape;
            const viewportRect = canvasViewport.getBoundingClientRect();
            
            // 計算點擊點在【未縮放】的內容區的座標
            const clientXUnscaled = (e.clientX - viewportRect.left + canvasViewport.scrollLeft) / currentScale;
            const clientYUnscaled = (e.clientY - viewportRect.top + canvasViewport.scrollTop) / currentScale;

            // 記錄起始點，用於區分點擊還是拖曳
            dragStartPos.x = clientXUnscaled;
            dragStartPos.y = clientYUnscaled;

            // --- 修正新積木的初始拖曳位置 ---
            if (isNew) {
                 // 計算讓積木中心大致對齊游標
                 const newX = clientXUnscaled - shape.l * GRID_SIZE / 2; 
                 const newY = clientYUnscaled - shape.w * GRID_SIZE / 2;
                 
                 // 立即更新 shape 的位置
                 shape.x = newX;
                 shape.y = newY;
                 
                 // 更新 DOM 的位置
                 if (el) {
                    el.style.left = `${newX}px`;
                    el.style.top = `${newY}px`;
                 }
                 // 重新計算 dragOffset 確保從此點開始平滑拖曳
                 dragOffset.x = clientXUnscaled - newX;
                 dragOffset.y = clientYUnscaled - newY;

            } else {
                // 計算拖曳偏移量 (點擊點相對於形狀左上角的偏移)
                dragOffset.x = clientXUnscaled - shape.x; 
                dragOffset.y = clientYUnscaled - shape.y;
            }
            // --- 修正結束 ---


            // --- 群組拖曳邏輯 (僅限 Mode 1) ---
            groupToMove = [];
            groupOffset = { x: 0, y: 0 };
            
            if (currentState.mode === 'cut' && shape.groupId) {
                // 這是 Mode 1 中已切割的積木（或未切割的原矩形）
                groupToMove = currentState.shapes.filter(s => s.groupId === shape.groupId);
                
                // 計算群組內其他積木相對於被拖曳積木的固定偏移量
                groupToMove.forEach(s => {
                    s.offsetX = s.x - shape.x;
                    s.offsetY = s.y - shape.y;
                });
            } else {
                 // Mode 2 或 Mode 1 中切割前的原矩形，單獨移動
                 groupToMove = [shape];
            }


            // 將形狀移到最上層
            (el || document.getElementById(shape.id)).style.zIndex = 40; 
        };

        // 拖曳中
        const onDrag = (e) => {
            if (!draggingShape) return;
            
            e.preventDefault(); 

            const viewportRect = canvasViewport.getBoundingClientRect();
            
            // 計算當前鼠標/觸摸點在【未縮放】的內容區的座標
            const clientXUnscaled = (e.clientX - viewportRect.left + canvasViewport.scrollLeft) / currentScale;
            const clientYUnscaled = (e.clientY - viewportRect.top + canvasViewport.scrollTop) / currentScale;

            // 1. 計算新的主拖曳 shape 邏輯位置
            let newX = clientXUnscaled - dragOffset.x;
            let newY = clientYUnscaled - dragOffset.y;

            // 2. 實時更新主 shape 位置
            draggingShape.x = newX;
            draggingShape.y = newY;
            
            // 3. 實時更新 DOM 元素位置 (包括群組中的其他元素)
            const dx_total = newX - dragStartPos.x;
            const dy_total = newY - dragStartPos.y;

            groupToMove.forEach(s => {
                const el = document.getElementById(s.id);
                if (el) {
                    if (s === draggingShape) {
                        // 主元素已在上面更新
                        el.style.left = `${draggingShape.x}px`;
                        el.style.top = `${draggingShape.y}px`;
                        el.style.boxShadow = '0 8px 20px rgba(0, 0, 0, 0.3)';
                    } else if (s.groupId === draggingShape.groupId && currentState.mode === 'cut') {
                        // 群組元素根據主元素和初始偏移量計算新位置
                        const groupNewX = newX + s.offsetX;
                        const groupNewY = newY + s.offsetY;

                        s.x = groupNewX;
                        s.y = groupNewY;

                        el.style.left = `${groupNewX}px`;
                        el.style.top = `${groupNewY}px`;
                    }
                }
            });
        };

        // 拖曳結束 (包括 pointerup 和 pointercancel)
        const endDrag = (e) => {
            if (!draggingShape) return;

            // 儲存最終未對齊網格的主 shape 位置
            const finalX = draggingShape.x;
            const finalY = draggingShape.y;

            // 計算最終點位，用於區分點擊還是拖曳
            const viewportRect = canvasViewport.getBoundingClientRect();
            const clientXUnscaled = (e.clientX - viewportRect.left + canvasViewport.scrollLeft) / currentScale;
            const clientYUnscaled = (e.clientY - viewportRect.top + canvasViewport.scrollTop) / currentScale;

            // 檢查是否為「點擊」(位移小於 5 像素)
            const dx = Math.abs(clientXUnscaled - dragStartPos.x);
            const dy = Math.abs(clientYUnscaled - dragStartPos.y);
            const isClick = dx < 5 && dy < 5; 

            // 如果是「點擊」且目標是「未切割的初始長方形」 (Mode 1)
            if (isClick && draggingShape.type === 'initial' && !draggingShape.isCut) {
                const clickedShape = draggingShape; 
                draggingShape = null; 
                groupToMove = [];
                openCutModal(clickedShape); // 開啟切割彈窗
                return; // 結束，不執行標準拖曳和貼齊邏輯
            }
            
            // --- 標準拖曳和貼齊邏輯 ---
            
            // 1. 吸附主元素到網格
            const snappedPos = findNearestGridPosition(finalX, finalY);
            const snapDeltaX = snappedPos.x - finalX;
            const snapDeltaY = snappedPos.y - finalY;
            
            // 2. 應用網格貼齊到整個群組
            groupToMove.forEach(s => {
                // 將所有元素的位置加上貼齊偏移量
                s.x += snapDeltaX;
                s.y += snapDeltaY;
                
                // 移除拖曳時的陰影並設置 Z-index
                const el = document.getElementById(s.id);
                if (el) {
                    el.style.left = `${s.x}px`;
                    el.style.top = `${s.y}px`;
                    el.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                    el.style.zIndex = 30;
                }
            });


            // 3. 僅在「小組大」模式下，檢查並更新正方形狀態
            if (currentState.mode === 'compose') {
                detectCompositeSquares();
            }
            
            // 4. 重設狀態
            draggingShape = null;
            groupToMove = [];
            dragOffset = { x: 0, y: 0 };
            groupOffset = { x: 0, y: 0 };
            
            // 5. 重新渲染以確保狀態和位置正確更新 (很重要，特別是 Mode 2 變色)
            renderCanvas();
        };

        // 輔助函數：檢查所有積木是否形成一個完整的正方形
        const detectCompositeSquares = () => {
            const blocks = currentState.shapes.filter(s => s.type === 'block');
            
            // 預設將所有積木的 isSquare 設為 false
            blocks.forEach(s => {
                s.isSquare = false;
            });

            if (blocks.length < 2) {
                return;
            }

            // 1. 找到整個組合體的邊界 (像素座標)
            let minX = blocks[0].x, minY = blocks[0].y;
            let maxX = blocks[0].x + blocks[0].l * GRID_SIZE;
            let maxY = blocks[0].y + blocks[0].w * GRID_SIZE;

            blocks.slice(1).forEach(s => {
                minX = Math.min(minX, s.x);
                minY = Math.min(minY, s.y);
                maxX = Math.max(maxX, s.x + s.l * GRID_SIZE);
                maxY = Math.max(maxY, s.y + s.w * GRID_SIZE);
            });

            // 2. 總長度和總寬度 (單位格)
            const totalWidthPixels = maxX - minX;
            const totalHeightPixels = maxY - minY;
            
            const totalL = totalWidthPixels / GRID_SIZE;
            const totalW = totalHeightPixels / GRID_SIZE;

            const isSquare = totalL > 0 && totalL === totalW;

            if (isSquare) {
                // 3. 檢查面積是否完全填滿
                const totalBlockArea = blocks.reduce((sum, s) => sum + (s.l * s.w), 0);
                const compositeArea = totalL * totalW;

                // 只有當總面積相等（即沒有空隙）且是正方形時
                if (totalBlockArea === compositeArea) {
                    
                    // 4. 標記為正方形 (只標記那些剛好在邊界內的積木)
                    let squareDetected = false;
                    blocks.forEach(s => {
                        // 檢查積木的四個邊界是否與組合成的正方形邊界對齊
                        const isContained = 
                            s.x >= minX && s.x + s.l * GRID_SIZE <= maxX && 
                            s.y >= minY && s.y + s.w * GRID_SIZE <= maxY;

                        if (isContained) {
                            s.isSquare = true;
                            squareDetected = true;
                        }
                    });

                    if (squareDetected) {
                         showMessage(`太棒了！您組合出了一個 ${totalL}x${totalW} 的正方形！`, false);
                    }
                    return;
                }
            }
        };
        
        // 確保在腳本載入後，所有事件處理器都是可用的
        window.setMode = setMode;
        window.showStartScreen = showStartScreen;
        window.renderInitialGrid = renderInitialGrid;
        window.openCutModal = openCutModal;
        window.closeCutModal = closeCutModal;
        window.performCut = performCut;
        window.confirmNewScreen = confirmNewScreen;
        window.newScreen = newScreen;
        window.closeConfirmModal = closeConfirmModal;
        window.renderSupplyArea = renderSupplyArea;
        window.downloadScreen = downloadScreen;
        window.duplicateShape = duplicateShape;
        window.onDrag = onDrag;
        window.endDrag = endDrag; 
        window.handleScaleChange = handleScaleChange; // 暴露縮放功能
        
        // 暴露繪圖工具功能
        window.setTool = setTool;
        window.updateBrushSize = updateBrushSize;
        window.clearDrawing = clearDrawing;


    </script>
</body>
</html>

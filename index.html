<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>幾何教具：面積分解與合成工具 (CodeCrafter)</title>
    <!-- 引入 Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 html2canvas CDN for image download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> 
    <style>
        /* 自定義 CSS 確保網格和拖曳功能視覺效果良好 */
        .grid-unit {
            border: 1px solid #ccc;
            box-sizing: border-box;
            background-color: white;
            transition: all 0.1s ease-out;
            cursor: grab;
            /* 針對觸控優化，確保拖曳順暢 */
            touch-action: none; 
            /* 讓方塊顯示網格效果 */
            background-image: linear-gradient(to right, #e5e7eb 1px, transparent 1px), linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 50px 50px;
        }
        /* Mode 1: 剩餘的紅色邊角料 */
        .grid-unit.red-remainder {
            background-color: #ef4444 !important; /* red-500 */
        }
        /* Mode 2: 合成的正方形 (紅底) */
        .grid-unit.is-square {
            background-color: #dc2626 !important; /* red-700 for detected square in compose mode */
            border: 3px solid #f97316; /* Orange ring for emphasis */
            box-shadow: 0 0 10px rgba(220, 38, 38, 0.7);
        }
        /* Mode 1: 已切割的原長方形 (半透明線框，用於比較) */
        .cut-original {
            background-color: rgba(209, 213, 219, 0.4) !important; /* Gray/transparent */
            border: 2px dashed #9ca3af !important; /* Dashed grey border */
            pointer-events: none; /* 無法點擊或拖曳 */
            box-shadow: none !important;
        }

        .workspace {
            /* 確保工作區足夠大，方便拖曳 */
            min-height: 800px; 
            border: 2px dashed #d1d5db; /* gray-300 */
            background-color: #f9fafb; /* gray-50 */
            position: relative;
            overflow: hidden; /* 防止內容溢出導致的滾動條 */
        }
        /* 隱藏原生數字輸入框的上下箭頭 */
        input[type='number']::-webkit-inner-spin-button,
        input[type='number']::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .dialog {
            z-index: 50;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans antialiased text-gray-800">

    <!-- 頂部標題和導航 -->
    <header class="bg-white shadow-lg sticky top-0 z-40">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            <h1 class="text-3xl font-extrabold text-indigo-600">幾何互動教具</h1>
            <div id="user-info" class="text-sm text-gray-500">
                <span id="auth-status" class="inline-block px-3 py-1 bg-gray-100 rounded-full">連線中...</span>
                <span id="user-id-display" class="ml-2 font-mono text-xs hidden">ID: N/A</span>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <!-- 訊息/錯誤提示區 -->
        <div id="message-box" class="mb-4 hidden p-3 rounded-lg bg-yellow-100 text-yellow-800 border border-yellow-300"></div>
        
        <!-- 模式選擇畫面 -->
        <section id="start-screen" class="flex flex-col items-center justify-center min-h-[50vh] transition-opacity duration-300">
            <h2 class="text-4xl font-bold mb-8 text-gray-700">請選擇操作模式</h2>
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-8">
                <button onclick="setMode('cut')" class="mode-btn bg-indigo-600 hover:bg-indigo-700 text-white p-6 rounded-xl shadow-xl transition transform hover:scale-[1.02] text-2xl font-semibold w-full sm:w-64">
                    大拆小 (切割分解)
                </button>
                <button onclick="setMode('compose')" class="mode-btn bg-teal-600 hover:bg-teal-700 text-white p-6 rounded-xl shadow-xl transition transform hover:scale-[1.02] text-2xl font-semibold w-full sm:w-64">
                    小組大 (合成組合)
                </button>
            </div>
        </section>

        <!-- 主要工作區 (預設隱藏) -->
        <section id="main-workspace" class="hidden transition-opacity duration-300">
            <!-- 模式標題和返回按鈕 -->
            <div class="flex justify-between items-center mb-6">
                <h2 id="mode-title" class="text-3xl font-bold text-gray-700"></h2>
                <button onclick="showStartScreen()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg transition duration-150">
                    < Back 返回模式選擇
                </button>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
                <!-- 控制面板區 (左側) -->
                <div class="lg:col-span-1 space-y-4 p-4 bg-white rounded-xl shadow-lg h-fit">
                    <h3 class="text-xl font-semibold border-b pb-2 mb-3">操作控制</h3>

                    <!-- 模式 1: 大拆小 (切割) 控制項 -->
                    <div id="controls-cut" class="space-y-4 hidden">
                        <div class="space-y-2">
                            <label class="block text-sm font-medium text-gray-700">原始長方形尺寸 (單位格)</label>
                            <input type="number" id="cut-length" placeholder="長度 (L)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" min="1">
                            <input type="number" id="cut-width" placeholder="寬度 (W)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" min="1">
                            <button onclick="renderInitialGrid()" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 rounded-lg transition duration-150">
                                建立新長方形 (可比較切法)
                            </button>
                        </div>
                        <p class="text-sm text-gray-500 pt-2 border-t mt-4">
                            提示: 點擊畫布上的 **白色** 長方形進行切割操作。
                        </p>
                    </div>

                    <!-- 模式 2: 小組大 (合成) 控制項 -->
                    <div id="controls-compose" class="space-y-4 hidden">
                        <div class="space-y-2">
                            <label class="block text-sm font-medium text-gray-700">單位長方形尺寸 (單位格)</label>
                            <input type="number" id="compose-unit-length" placeholder="單位長度 (L)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-teal-500 focus:border-teal-500" value="1" min="1">
                            <input type="number" id="compose-unit-width" placeholder="單位寬度 (W)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-teal-500 focus:border-teal-500" value="1" min="1">
                            <button onclick="renderSupplyArea()" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 rounded-lg transition duration-150">
                                建立單位積木
                            </button>
                        </div>

                        <!-- 供應區 (僅用於 Mode 2) -->
                        <div class="pt-4 border-t">
                            <h4 class="text-lg font-medium mb-2">供應區 (拖曳至畫布)</h4>
                            <div id="supply-area" class="flex flex-wrap gap-2 p-2 border border-gray-200 rounded-lg min-h-[60px] bg-gray-50">
                                <!-- 單位積木將會被 JS 動態加入 -->
                            </div>
                        </div>
                    </div>

                    <div class="pt-4 border-t space-y-3">
                         <!-- 儲存/新增畫面按鈕 -->
                        <button onclick="saveState()" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                            儲存畫面 (雲端)
                        </button>
                        <button onclick="downloadScreen()" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                             <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4m-6-4l-3 3m0 0l-3-3m3 3V3"></path></svg>
                            下載畫面 (圖片)
                        </button>
                        <button onclick="confirmNewScreen()" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 rounded-lg transition duration-150 flex items-center justify-center">
                             <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v3m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            新增畫面 (清除)
                        </button>
                    </div>

                    <!-- 載入歷史記錄 -->
                    <div class="pt-4 border-t space-y-2">
                        <h4 class="text-lg font-medium">載入記錄</h4>
                        <select id="save-select" class="w-full p-2 border border-gray-300 rounded-lg" onchange="loadState(this.value)">
                            <option value="" disabled selected>選擇要載入的記錄</option>
                        </select>
                    </div>

                </div>

                <!-- 畫布/工作區 (右側) -->
                <div class="lg:col-span-3">
                    <div id="canvas-container" class="workspace rounded-xl shadow-inner relative">
                        <!-- 幾何圖形將在此處渲染 -->
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- 切割輸入彈窗 (Modal) -->
    <div id="cut-modal" class="dialog fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm space-y-4">
            <h3 class="text-xl font-bold">切割操作</h3>
            <p>請決定要用多少「單位格邊長」的正方形來切割這個長方形:</p>
            
            <div class="flex items-center space-x-3">
                <label for="cut-square-size" class="font-medium">正方形邊長 (單位格):</label>
                <input type="number" id="cut-square-size" class="w-20 p-2 border border-gray-300 rounded-lg text-center" min="1">
            </div>

            <p id="cut-info" class="text-sm text-gray-500"></p>

            <div class="flex justify-end space-x-3">
                <button onclick="closeCutModal()" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 rounded-lg">取消</button>
                <button onclick="performCut()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg">確認切割</button>
            </div>
        </div>
    </div>
    
    <!-- 警告/確認彈窗 (用於新增畫面) -->
    <div id="confirm-modal" class="dialog fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm space-y-4">
            <h3 class="text-xl font-bold text-red-600">確認清除畫面</h3>
            <p>您確定要清除目前畫布上的所有內容，並開啟一個新的畫面嗎？此操作無法撤銷。</p>
            <div class="flex justify-end space-x-3">
                <button onclick="closeConfirmModal()" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 rounded-lg">取消</button>
                <button onclick="newScreen()" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg">確認新增</button>
            </div>
        </div>
    </div>


    <!-- 引入 Firebase JS SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // 設置日誌級別為 Debug
        setLogLevel('Debug');

        // ==== 全局變數初始化 ====
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth;
        let currentUserId = null;
        let isAuthReady = false;

        // 將重要變數和 Firebase 函式附加到 window 對象，以便在非 module 腳本中存取 (Fix for ReferenceError)
        window.db = db;
        window.auth = auth;
        window.currentUserId = currentUserId;
        // 將 Firestore 核心函式暴露給全局
        window.query = query;
        window.collection = collection;
        window.onSnapshot = onSnapshot;
        window.serverTimestamp = serverTimestamp;
        window.doc = doc; // 新增 doc
        window.getDoc = getDoc; // 新增 getDoc
        window.addDoc = addDoc; // 新增 addDoc

        // ==== Firebase 初始化與認證 ====
        const initFirebase = async () => {
            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase 配置缺失。儲存功能將無法使用。");
                document.getElementById('auth-status').textContent = '連線失敗 (配置缺失)';
                return;
            }

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            window.db = db;
            window.auth = auth;

            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase 認證失敗:", error);
                document.getElementById('auth-status').textContent = '認證失敗';
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUserId = user.uid;
                    window.currentUserId = user.uid;
                    document.getElementById('auth-status').textContent = '已連線';
                    document.getElementById('user-id-display').textContent = `ID: ${currentUserId}`;
                    document.getElementById('user-id-display').classList.remove('hidden');
                    isAuthReady = true;
                    // 認證成功後開始監聽資料
                    if (window.startStateListener) {
                         window.startStateListener();
                    }
                } else {
                    currentUserId = crypto.randomUUID(); // 未認證時使用隨機 ID
                    window.currentUserId = currentUserId;
                    document.getElementById('auth-status').textContent = '匿名連線';
                    document.getElementById('user-id-display').textContent = `ID: ${currentUserId.substring(0, 8)}...`;
                    document.getElementById('user-id-display').classList.remove('hidden');
                    isAuthReady = true;
                    if (window.startStateListener) {
                         window.startStateListener();
                    }
                }
            });
        };

        initFirebase();
    </script>

    <script>
        // ==== 全局狀態與配置 ====
        const GRID_SIZE = 50; // 每個單位方格在螢幕上的像素大小 (50px x 50px)
        let currentState = {
            mode: null, // 'cut' or 'compose'
            shapes: [],
            dims: { length: 0, width: 0 } // For Mode 1: initial dimensions. For Mode 2: unit dimensions.
        };
        let draggingShape = null;
        let dragOffset = { x: 0, y: 0 };
        let cutTargetShape = null; // 儲存 Mode 1 中被點擊的長方形

        // 訪問 window 上的 Firebase 變數
        const getDB = () => window.db;
        const getAuth = () => window.auth;
        const getUserId = () => window.currentUserId;
        
        // 確保可以存取 FireStore 函式 (FIX: 避免 destructuring，直接從 window 取得以確保時序正確)
        const query = window.query;
        const collection = window.collection;
        const onSnapshot = window.onSnapshot;
        const serverTimestamp = window.serverTimestamp;
        const doc = window.doc;
        const getDoc = window.getDoc;
        const addDoc = window.addDoc;


        // Firestore 路徑
        const getCollectionPath = () => {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const userId = getUserId();
            // 私人資料路徑
            return `artifacts/${appId}/users/${userId}/geometry_tool`;
        };

        // ==== UI/彈窗工具函數 ====
        const messageBox = document.getElementById('message-box');
        const showMessage = (msg, isError = false) => {
            messageBox.textContent = msg;
            messageBox.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800');
            messageBox.classList.add(isError ? 'bg-red-100' : 'bg-yellow-100', isError ? 'text-red-800' : 'text-yellow-800');
            
            // 3秒後自動隱藏，除非是錯誤
            if (!isError) {
                setTimeout(() => messageBox.classList.add('hidden'), 3000);
            }
        };

        const showStartScreen = () => {
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('main-workspace').classList.add('hidden');
            currentState.mode = null;
            newScreen(false); // 清除畫布但不彈出確認窗
        };

        const setMode = (mode) => {
            currentState.mode = mode;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('main-workspace').classList.remove('hidden');

            const titleElement = document.getElementById('mode-title');
            const cutControls = document.getElementById('controls-cut');
            const composeControls = document.getElementById('controls-compose');

            if (mode === 'cut') {
                titleElement.textContent = '模式：大拆小 (切割分解)';
                cutControls.classList.remove('hidden');
                composeControls.classList.add('hidden');
            } else {
                titleElement.textContent = '模式：小組大 (合成組合)';
                cutControls.classList.add('hidden');
                composeControls.classList.remove('hidden');
            }
            newScreen(false);
        };

        // ==== 畫面下載功能 (新需求) ====
        const downloadScreen = () => {
            showMessage('正在捕捉畫面並下載...', false);
            // 使用 html2canvas 捕捉整個工作區 (canvas-container)
            const targetElement = document.getElementById('canvas-container');
            
            // 暫時隱藏 ID 顯示，讓畫面更乾淨
            document.getElementById('user-info').style.opacity = 0; 

            // 將畫布容器設置為白色背景，避免截圖時背景透明
            targetElement.style.backgroundColor = '#ffffff';

            html2canvas(targetElement, { 
                scale: 2, // 提高解析度
                useCORS: true, 
            }).then(canvas => {
                // 恢復 ID 顯示和背景色
                document.getElementById('user-info').style.opacity = 1;
                targetElement.style.backgroundColor = '#f9fafb';

                // 轉換為圖片連結並下載
                const image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
                const link = document.createElement('a');
                link.download = `幾何教具畫面_${new Date().getTime()}.png`;
                link.href = image;
                link.click();
                showMessage('畫面下載完成！', false);
            }).catch(e => {
                console.error("畫面下載失敗: ", e);
                showMessage('下載畫面失敗，請確保畫布上有內容。', true);
            });
        };


        // ==== Firebase 儲存/載入邏輯 ====

        // 開始監聽用戶的儲存記錄
        window.startStateListener = () => {
            if (!getDB()) return; // 確保 db 已初始化
            
            const q = query(collection(getDB(), getCollectionPath())); 
            
            onSnapshot(q, (snapshot) => {
                const saveSelect = document.getElementById('save-select');
                saveSelect.innerHTML = '<option value="" disabled selected>選擇要載入的記錄</option>';
                
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const option = document.createElement('option');
                    option.value = doc.id;
                    const timestamp = data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleString() : '未知時間';
                    option.textContent = `${data.mode === 'cut' ? '切割' : '合成'} - ${timestamp}`;
                    saveSelect.appendChild(option);
                });
                showMessage('歷史記錄已更新。', false);
            }, (error) => {
                console.error("Error listening to documents: ", error);
                showMessage('無法載入歷史記錄。請檢查連線。', true);
            });
        };

        // 載入儲存記錄
        const loadState = async (docId) => {
            if (!docId || !getDB()) return;

            try {
                showMessage('正在載入畫面...', false);
                const docRef = doc(getDB(), getCollectionPath(), docId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    
                    // 設定模式
                    setMode(data.mode); 
                    
                    // 恢復狀態
                    currentState.mode = data.mode;
                    currentState.shapes = data.shapes;
                    currentState.dims = data.dims;

                    // 重新渲染畫布
                    renderCanvas();
                    showMessage('畫面載入成功！', false);
                } else {
                    showMessage('找不到該記錄。', true);
                }
            } catch (e) {
                console.error("載入狀態時發生錯誤: ", e);
                showMessage('載入狀態失敗。', true);
            }
        };

        // 儲存目前狀態 (雲端)
        const saveState = async () => {
            if (!getDB() || !currentState.mode) {
                showMessage('請先選擇模式並操作畫布。', true);
                return;
            }
            if (currentState.shapes.length === 0) {
                 showMessage('畫布為空，無法儲存。', true);
                 return;
            }

            try {
                showMessage('正在儲存畫面至雲端...', false);
                
                const dataToSave = {
                    mode: currentState.mode,
                    shapes: currentState.shapes,
                    dims: currentState.dims,
                    timestamp: serverTimestamp()
                };

                await addDoc(collection(getDB(), getCollectionPath()), dataToSave);

                showMessage('畫面儲存成功 (雲端)！', false);
            } catch (e) {
                console.error("儲存狀態時發生錯誤: ", e);
                showMessage('儲存狀態失敗。', true);
            }
        };

        // ==== 核心畫布渲染與互動 ====
        const canvasContainer = document.getElementById('canvas-container');

        const renderCanvas = () => {
            canvasContainer.innerHTML = '';
            
            // 渲染所有形狀
            currentState.shapes.forEach(shape => {
                const el = document.createElement('div');
                el.id = shape.id;
                
                // 基礎樣式
                el.className = 'grid-unit absolute rounded-md shadow-md transition-shadow duration-200';
                el.style.width = `${shape.l * GRID_SIZE}px`;
                el.style.height = `${shape.w * GRID_SIZE}px`;
                el.style.left = `${shape.x}px`;
                el.style.top = `${shape.y}px`;
                el.style.zIndex = shape.type === 'supply' ? 10 : 30; // 供應區在下方

                // Mode 1: 比較切法 - 處理已切割的原長方形 (線框)
                if (currentState.mode === 'cut' && shape.type === 'initial' && shape.isCut) {
                    el.classList.add('cut-original'); // 使用 CSS 處理半透明線框
                    el.style.zIndex = 10; 
                } 
                // Mode 1: 待切割的原長方形
                else if (currentState.mode === 'cut' && shape.type === 'initial' && !shape.isCut) {
                    el.onclick = () => openCutModal(shape); 
                    el.style.cursor = 'pointer';
                    el.style.zIndex = 20;
                    el.style.backgroundColor = 'white';
                }
                // Mode 1: 剩餘邊角料
                else if (currentState.mode === 'cut' && shape.type === 'remainder') {
                    el.classList.add('red-remainder');
                    el.style.zIndex = 30;
                }
                // Mode 2: 合成的積木 (Block) 或切割後的正方形 (Cut-Square)
                else {
                    el.style.backgroundColor = shape.color || 'white';
                    el.style.zIndex = 30;
                }
                
                // Mode 2: 合成正方形變紅
                if (currentState.mode === 'compose' && shape.type === 'block' && shape.isSquare) {
                    el.classList.add('is-square', 'cursor-pointer');
                    el.setAttribute('title', '點擊複製此正方形');
                    el.onclick = (e) => {
                        e.stopPropagation(); 
                        duplicateShape(shape)
                    };
                }

                // 添加拖曳事件
                if (currentState.mode === 'compose' && shape.type !== 'supply') {
                    el.onpointerdown = (e) => startDrag(e, shape);
                }

                canvasContainer.appendChild(el);
            });

            // 僅在合成模式下綁定畫布上的拖曳結束事件
            if (currentState.mode === 'compose') {
                canvasContainer.onpointerup = endDrag;
                canvasContainer.onpointermove = onDrag;
                canvasContainer.onpointercancel = endDrag;
            } else {
                canvasContainer.onpointerup = null;
                canvasContainer.onpointermove = null;
                canvasContainer.onpointercancel = null;
            }
        };

        // 清除畫布
        const newScreen = (showConfirmation = true) => {
             if (showConfirmation) {
                document.getElementById('confirm-modal').classList.remove('hidden');
                document.getElementById('confirm-modal').classList.add('flex');
                return;
            }

            // 實際清除邏輯
            currentState.shapes = [];
            currentState.dims = { length: 0, width: 0 };
            document.getElementById('cut-length').value = '';
            document.getElementById('cut-width').value = '';
            document.getElementById('compose-unit-length').value = '1';
            document.getElementById('compose-unit-width').value = '1';
            document.getElementById('supply-area').innerHTML = '';
            renderCanvas();
            closeConfirmModal();
            showMessage('畫面已重置。', false);
        };
        const closeConfirmModal = () => {
            document.getElementById('confirm-modal').classList.add('hidden');
            document.getElementById('confirm-modal').classList.remove('flex');
        };
        const confirmNewScreen = () => newScreen(true);
        

        // ==== Mode 1: 大拆小 (切割) 邏輯 ====
        
        // 輔助函數：找到一個不與現有形狀重疊的起始位置
        const findNewPlacement = (l, w) => {
            const canvasRect = canvasContainer.getBoundingClientRect();
            // 由於 CSS min-height 是 800px，我們以 GRID_SIZE 計算最大可容納單元格數
            const canvasWidthUnits = Math.floor(canvasRect.width / GRID_SIZE) - 1;
            const canvasHeightUnits = Math.floor(canvasRect.height / GRID_SIZE) - 1;

            // 簡單策略：從 (1, 1) 開始，掃描第一個不重疊的 GRID_SIZE 網格點
            for (let y = 1; y < canvasHeightUnits - w; y++) {
                for (let x = 1; x < canvasWidthUnits - l; x++) {
                    const newShapeBoundary = {
                        x: x * GRID_SIZE,
                        y: y * GRID_SIZE,
                        l: l,
                        w: w
                    };
                    
                    let overlaps = false;
                    for (const existingShape of currentState.shapes.filter(s => s.type !== 'supply')) {
                        // 檢查重疊 (使用網格單元)
                        if (newShapeBoundary.x < existingShape.x + existingShape.l * GRID_SIZE &&
                            newShapeBoundary.x + newShapeBoundary.l * GRID_SIZE > existingShape.x &&
                            newShapeBoundary.y < existingShape.y + existingShape.w * GRID_SIZE &&
                            newShapeBoundary.y + newShapeBoundary.w * GRID_SIZE > existingShape.y) {
                            overlaps = true;
                            break;
                        }
                    }
                    if (!overlaps) {
                        return { x: newShapeBoundary.x, y: newShapeBoundary.y };
                    }
                }
            }
            return { x: 20, y: 20 }; // 如果找不到空間，使用預設值
        };


        const renderInitialGrid = () => {
            const length = parseInt(document.getElementById('cut-length').value);
            const width = parseInt(document.getElementById('cut-width').value);

            if (isNaN(length) || isNaN(width) || length <= 0 || width <= 0) {
                showMessage('請輸入有效的長度和寬度 (需為正整數)。', true);
                return;
            }
            
            // 清除之前的模式維度設定，因為每個長方形的維度可能不同
            currentState.dims = { length, width };

            // 找到不重疊的位置，讓不同的長方形可以並排比較
            const { x: newX, y: newY } = findNewPlacement(length, width);

            // 建立一個初始大矩形
            const initialShape = {
                id: 'initial-' + Date.now(),
                type: 'initial',
                l: length,
                w: width,
                x: newX,
                y: newY,
                color: 'white',
                isCut: false, // 尚未被切割
                isInitial: true // 標記為原始待切割
            };
            currentState.shapes.push(initialShape);
            renderCanvas();
            showMessage(`已建立新的 ${length}x${width} 長方形。點擊它來切割。`, false);
        };

        const openCutModal = (shape) => {
            if (shape.isCut) return; // 已切割的不能再點擊
            cutTargetShape = shape;
            document.getElementById('cut-square-size').value = 1; // 預設值
            document.getElementById('cut-info').textContent = `目標長方形尺寸: ${shape.l} (長) x ${shape.w} (寬)`;

            document.getElementById('cut-modal').classList.remove('hidden');
            document.getElementById('cut-modal').classList.add('flex');
        };

        const closeCutModal = () => {
             document.getElementById('cut-modal').classList.add('hidden');
             document.getElementById('cut-modal').classList.remove('flex');
        };
        
        const performCut = () => {
            if (!cutTargetShape) return;

            const target = cutTargetShape;
            const squareSize = parseInt(document.getElementById('cut-square-size').value);

            if (isNaN(squareSize) || squareSize <= 0 || squareSize > Math.min(target.l, target.w)) {
                showMessage(`切割的正方形邊長必須是正整數，且不能大於長或寬 (${target.l}x${target.w})`, true);
                return;
            }

            // 1. 將原始大矩形標記為「已切割」並移除可點擊屬性
            target.isCut = true;
            target.isInitial = false; // 不再接受點擊切割

            let currentL = target.l;
            let currentW = target.w;
            let currentX = target.x;
            let currentY = target.y;

            // 2. 計算可切出多少個完整的正方形
            const numL = Math.floor(currentL / squareSize);
            const numW = Math.floor(currentW / squareSize);
            
            let cutCount = 0;

            // 3. 產出切割後的正方形
            for (let i = 0; i < numL; i++) {
                for (let j = 0; j < numW; j++) {
                    const newSquare = {
                        id: 'cut-sq-' + Date.now() + '-' + i + j,
                        type: 'cut-square',
                        l: squareSize,
                        w: squareSize,
                        x: currentX + i * squareSize * GRID_SIZE,
                        y: currentY + j * squareSize * GRID_SIZE,
                        color: 'white',
                        isSquare: true,
                    };
                    currentState.shapes.push(newSquare);
                    cutCount++;
                }
            }
            
            // 4. 計算剩餘部分
            const remainderL = currentL % squareSize;
            const remainderW = currentW % squareSize;
            
            // 剩餘矩形 1: 在長度方向被切掉後，寬度方向的殘餘部分 (位於右側)
            if (remainderL > 0) {
                const remainderShape = {
                    id: 'rem-l-' + Date.now(),
                    type: 'remainder',
                    l: remainderL,
                    w: currentW, // 整個寬度
                    x: currentX + numL * squareSize * GRID_SIZE,
                    y: currentY,
                    color: 'red',
                    isSquare: false
                };
                currentState.shapes.push(remainderShape);
                cutCount++;
            }

            // 剩餘矩形 2: 在寬度方向被切掉後，長度方向的殘餘部分 (位於下方)
            if (remainderW > 0) {
                const remainderShape = {
                    id: 'rem-w-' + Date.now(),
                    type: 'remainder',
                    l: numL * squareSize, // 僅限被完整切出正方形的長度
                    w: remainderW,
                    x: currentX,
                    y: currentY + numW * squareSize * GRID_SIZE,
                    color: 'red',
                    isSquare: false
                };
                currentState.shapes.push(remainderShape);
                cutCount++;
            }


            // 5. 更新並關閉
            cutTargetShape = null;
            closeCutModal();
            renderCanvas();
            showMessage(`已在原長方形上切割出 ${cutCount} 個新形狀。`, false);
        };


        // ==== Mode 2: 小組大 (合成) 邏輯 ====
        
        const renderSupplyArea = () => {
            const supplyArea = document.getElementById('supply-area');
            supplyArea.innerHTML = '';
            
            const l = parseInt(document.getElementById('compose-unit-length').value);
            const w = parseInt(document.getElementById('compose-unit-width').value);

            if (isNaN(l) || isNaN(w) || l <= 0 || w <= 0) {
                showMessage('請輸入有效的單位長度和寬度 (需為正整數)。', true);
                return;
            }
            currentState.dims = { length: l, width: w };


            // 檢查供應區是否已經有此單位的形狀，如果沒有，就新增一個。
            const existingSupplyShape = currentState.shapes.find(s => s.type === 'supply' && s.l === l && s.w === w);
            if (!existingSupplyShape) {
                 const supplyShape = {
                    id: 'supply-' + l + 'x' + w,
                    type: 'supply',
                    l: l,
                    w: w,
                    x: 0, 
                    y: 0,
                    color: 'white',
                    isSquare: l === w
                };
                currentState.shapes.push(supplyShape);
            }
            
            // 在供應區創建可拖曳的原型
            const supplyElement = document.createElement('div');
            supplyElement.id = 'supply-proto-' + l + 'x' + w;
            supplyElement.className = 'grid-unit shadow-lg cursor-pointer hover:shadow-xl transition';
            supplyElement.style.width = `${l * GRID_SIZE}px`;
            supplyElement.style.height = `${w * GRID_SIZE}px`;
            supplyElement.textContent = `${l}x${w}`;
            supplyElement.style.lineHeight = `${w * GRID_SIZE}px`;
            supplyElement.style.textAlign = 'center';
            supplyElement.style.fontSize = '12px';
            supplyElement.style.position = 'relative'; // 確保網格樣式顯示
            supplyElement.style.zIndex = 10; // 確保在供應區可見

            // 複製事件 (從供應區拖曳時)
            supplyElement.onpointerdown = (e) => {
                e.stopPropagation(); // 阻止冒泡到畫布的 endDrag
                
                // 創建一個新的 shape 實例並開始拖曳
                const newShape = {
                    id: 'block-' + Date.now(),
                    type: 'block',
                    l: l,
                    w: w,
                    x: e.clientX, // 暫時設置為點擊位置
                    y: e.clientY,
                    color: 'white',
                    isSquare: l === w,
                    isDragging: true
                };

                currentState.shapes.push(newShape);
                renderCanvas(); // 渲染新的 shape
                
                // 找到新渲染的 DOM 元素
                const el = document.getElementById(newShape.id);
                if (el) {
                    startDrag(e, newShape, true, el);
                } else {
                     currentState.shapes.pop(); // 失敗則移除
                }
            };

            supplyArea.appendChild(supplyElement);
        };
        
        // 複製紅色正方形 (F. 紅色的正方形可以長按複製出來 - 改為點擊)
        const duplicateShape = (shape) => {
            if (!shape.isSquare || currentState.mode !== 'compose') return;

            const newShape = {
                id: 'block-' + Date.now(),
                type: 'block',
                l: shape.l,
                w: shape.w,
                x: shape.x + GRID_SIZE, // 稍微偏移
                y: shape.y + GRID_SIZE,
                color: 'white', // 複製出來的是普通白色積木
                isSquare: false, // 複製出來後不再自動是紅色，除非重新組合
                isDragging: false 
            };
            currentState.shapes.push(newShape);
            renderCanvas();
            showMessage(`已複製一個 ${shape.l}x${shape.w} 的積木。`, false);
        };

        // 輔助函數：將像素位置對齊到網格
        const findNearestGridPosition = (x, y) => {
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        };

        // 拖曳開始
        const startDrag = (e, shape, isNew = false, el = null) => {
            if (currentState.mode !== 'compose') return;

            // 確保是左鍵點擊 (或觸摸開始)
            if (e.button !== 0 && !e.pointerType.includes('touch')) return; 
            e.preventDefault();
            e.stopPropagation();

            draggingShape = shape;
            const rect = (el || document.getElementById(shape.id)).getBoundingClientRect();
            
            // 計算拖曳偏移量 (點擊點相對於形狀左上角的偏移)
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;

            // 將形狀移到最上層
            (el || document.getElementById(shape.id)).style.zIndex = 40; 
        };

        // 拖曳中
        const onDrag = (e) => {
            if (!draggingShape) return;
            
            e.preventDefault(); // 防止滾動等瀏覽器默認行為

            const canvasRect = canvasContainer.getBoundingClientRect();
            
            let newX = e.clientX - canvasRect.left - dragOffset.x;
            let newY = e.clientY - canvasRect.top - dragOffset.y;

            // 實時更新形狀位置 (不吸附)
            draggingShape.x = newX;
            draggingShape.y = newY;

            // 更新 DOM 元素位置
            const el = document.getElementById(draggingShape.id);
            if (el) {
                el.style.left = `${newX}px`;
                el.style.top = `${newY}px`;
                el.style.boxShadow = '0 8px 20px rgba(0, 0, 0, 0.3)'; // 拖曳時增加陰影
            }
        };

        // 拖曳結束 (包括 pointerup 和 pointercancel)
        const endDrag = (e) => {
            if (!draggingShape) return;
            
            // 處理釋放時的邏輯
            
            // 1. 吸附到網格 (D. 畫面上的長方形具備自動貼齊的功能)
            const snappedPos = findNearestGridPosition(draggingShape.x, draggingShape.y);
            draggingShape.x = snappedPos.x;
            draggingShape.y = snappedPos.y;

            // 2. 移除拖曳時的陰影
            const el = document.getElementById(draggingShape.id);
            if (el) {
                el.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                el.style.zIndex = 30;
            }

            // 3. 檢查並更新畫布上的正方形狀態 (E. 組合起來的長方形具備正方形的特徵，會自動變成紅色)
            detectCompositeSquares();
            
            // 4. 重設狀態
            draggingShape = null;
            dragOffset = { x: 0, y: 0 };

            // 5. 重新渲染以確保狀態和位置正確更新 (此呼叫確保 isSquare 類別被正確套用)
            renderCanvas();
        };

        // 輔助函數：檢查所有積木是否形成一個完整的正方形 (Fix for E)
        const detectCompositeSquares = () => {
            // 只考慮 type: 'block' 的形狀
            const blocks = currentState.shapes.filter(s => s.type === 'block');

            // 預先將所有積木的 isSquare 狀態重置為 false
            blocks.forEach(s => {
                s.isSquare = false;
            });

            if (blocks.length < 2) {
                return;
            }

            // 1. 找到整個組合體的邊界 (使用已貼齊的像素座標)
            let minX = blocks[0].x, minY = blocks[0].y;
            let maxX = blocks[0].x + blocks[0].l * GRID_SIZE;
            let maxY = blocks[0].y + blocks[0].w * GRID_SIZE;

            blocks.slice(1).forEach(s => {
                minX = Math.min(minX, s.x);
                minY = Math.min(minY, s.y);
                maxX = Math.max(maxX, s.x + s.l * GRID_SIZE);
                maxY = Math.max(maxY, s.y + s.w * GRID_SIZE);
            });

            // 2. 總長度和總寬度 (單位格)
            const totalWidthPixels = maxX - minX;
            const totalHeightPixels = maxY - minY;
            
            const totalL = totalWidthPixels / GRID_SIZE;
            const totalW = totalHeightPixels / GRID_SIZE;

            const isSquare = totalL > 0 && totalL === totalW;

            if (isSquare) {
                // 3. 檢查面積是否完全填滿
                const totalBlockArea = blocks.reduce((sum, s) => sum + (s.l * s.w), 0);
                const compositeArea = totalL * totalW;

                // 只有當總面積相等（即沒有空隙）且是正方形時
                if (totalBlockArea === compositeArea) {
                    
                    // 4. 標記為正方形
                    blocks.forEach(s => {
                        // 只標記那些確實位於這個組合邊界內的積木
                        if (s.x >= minX && s.x + s.l * GRID_SIZE <= maxX && 
                            s.y >= minY && s.y + s.w * GRID_SIZE <= maxY) {
                            s.isSquare = true;
                        }
                    });
                    showMessage(`太棒了！您組合出了一個 ${totalL}x${totalW} 的正方形！`, false);
                    return;
                }
            }
            
            // 如果不是正方形或未填滿， isSquare 已經是 false，無需額外操作
        };
        
        // 確保在腳本載入後，所有事件處理器都是可用的
        window.setMode = setMode;
        window.showStartScreen = showStartScreen;
        window.renderInitialGrid = renderInitialGrid;
        window.openCutModal = openCutModal;
        window.closeCutModal = closeCutModal;
        window.performCut = performCut;
        window.confirmNewScreen = confirmNewScreen;
        window.newScreen = newScreen;
        window.closeConfirmModal = closeConfirmModal;
        window.renderSupplyArea = renderSupplyArea;
        window.saveState = saveState;
        window.loadState = loadState;
        window.downloadScreen = downloadScreen;
        window.duplicateShape = duplicateShape;
        window.onDrag = onDrag;
        window.endDrag = endDrag; 

    </script>
</body>
</html>
